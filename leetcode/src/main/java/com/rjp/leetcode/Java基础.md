Java基础记录：

1. **类加载，详情见https://juejin.im/post/5a810b0e5188257a5c606a85**

   - 加载阶段：

      - 1).通过一个类的全限定名称来获取定义此类的二进制字节流。	
      - 2).将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
      - 3).在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

   - 验证：验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

   - 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。 注：

      - 1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中
      - 2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

   - 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。*符号引用（Symbolic Reference）*：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。*直接引用（Direct Reference）*：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

      - 1)、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 2)、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
      - 3)、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
      - 4)、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。

   - 初始化：类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

      **JVM初始化步骤**

      1)、假如这个类还没有被加载和连接，则程序先加载并连接该类

      2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类

      3)、假如类中有初始化语句，则系统依次执行这些初始化语句

      初始化阶段时执行类构造器方法()的过程。

      1）类构造器方法（clinit方法）是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。

      2）类构造器方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的类构造器方法执行之前，父类的类构造器方法已经执行完毕，因此在虚拟机中第一个执行的类构造器方法的类一定是java.lang.Object。

      3）由于父类的类构造器方法方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

      4）类构造器方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成类构造器方法。

      5）接口中可能会有变量赋值操作，因此接口也会生成类构造器方法。但是接口与类不同，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的类构造器方法。

      6）虚拟机会保证一个类的类构造器方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行类构造器方法完毕。如果在一个类的类构造器方法中有耗时很长的操作，那么就可能造成多个进程阻塞。

      

   - 

2. **反射https://juejin.im/post/598ea9116fb9a03c335a99a4**

3. 1. getFields和getDeclareFields的区别
   2. 通过反射是否可以修改常量（final修饰），一般情况基本类型无效，对象类型可以，但基本类型也可以改，通过构造函数赋值的final变量，或者赋值时用三目表达式赋值

4. **public > protected > default > private**

5. **Volatile，详解见单独文档**

6. **==、equal、hashCode的区别https://juejin.im/post/5b0044bf518825673564ca0d**

   - ==号作用：
     - 基本类型：比较的就是值是否相同
     - 引用类型：比较的就是地址值是否相同
   - equals 的作用：
     - 引用类型：默认情况下，比较的是地址值。在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。

7. **数据类型：**

   - char占用的是2个字节 16位，所以一个char类型的可以存储一个汉字
   - 整型：
     - byte:1个字节 8位 -128~127
     - short ：2个字节 16位
     - int ：4个字节 32位
     - long：8个字节 64位
   - 浮点型：（注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。）
     - float：4个字节 32 位
     - double ：8个字节 64位
   - char类型：char：2个字节。
   - Boolean 类型：boolean: （true or false）（并未指明是多少字节  1字节  1位 4字节）

8. **int和Integer**

   - Integer是int的包装类；int是基本数据类型；
   - Integer变量必须实例化后才能使用；int变量不需要；
   - Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；
   - Integer的默认值是null；int的默认值是0。
   -  java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。
   - java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）

9. **多态：指允许不同类的对象对同一消息做出响应，即同一消息可以根据发送的对象的不同而采用多种不同的行为。https://juejin.im/post/5aa8e118518825557005b762**

10. **String、StringBuffer、StringBuilder区别https://juejin.im/post/5ce2a3db6fb9a07ebe749314**

11. **什么是内部类？内部类的作用**

    - 内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据

      - 当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了

    - 内部类可以对同一包中的其他类隐藏起来

      - 关于内部类的第二个好处其实很显而易见，我们都知道外部类即普通的类不能使用 private protected 访问权限符来修饰的，而内部类则可以使用 private 和 protected 来修饰。当我们使用 private 来修饰内部类的时候这个类就对外隐藏了。这看起来没什么作用，但是当内部类实现某个接口的时候，在进行向上转型，对外部来说，就完全隐藏了接口的实现了

    - 内部类可以实现 java 单继承的缺陷

    - 对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的

    - 静态内部类和非静态内部类的区别

      - 静态内部类可以有静态成员，而非静态内部类则不能有静态成员
    - 静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；
      - 非静态内部类的非静态成员可以访问外部类的非静态变量。静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建。

12. **泛型中extends和super的区别**

    - `extends`也称为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。`<? extends T>`表示是T的某个子类型，**但是不确定具体是哪个子类**，所以无法add元素到列表
    - `super`也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。<? super T> 表示参数化类型是此类型的超类型（父类型），直至Object，代表是T的某个父类型，**但并不确定具体是哪个父类**，所以add只能添加T的子类或者T，get只能用Object接收。

13. 父类的静态方法能否被子类重写：不能

14. 进程和线程的区别**https://blog.csdn.net/mxsgoden/article/details/8821936**

15. final，finally，finalize的区别：

    - final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
    - finally 是异常处理语句结构的一部分，表示总是执行.
    - finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

16. Serializable 和Parcelable 的区别

    - 名词解释：
       - 对象的序列化 : 把Java对象转换为字节序列并存储至一个储存媒介的过程。
       - 对象的反序列化:把字节序列恢复为Java对象的过程。
    - 区别：两者最大的区别在于存储媒介的不同，Serializable使用**I/O**读写存储在硬盘上，而Parcelable是直接在内存中（Native内存）读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。
    - 优缺点：
       - Serializable原理是反射，在序列化的时候会产生大量的临时变量，从而引起频繁的GC。
       - Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了
    - 总结使用选择：Parcelable的性能比Serializable好，因为后者在反射过程频繁GC，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。
    - 注意： Binder 的缓冲区是有大小限制的（有些手机是 2 M），而一个进程默认有 16 个 `Binder` 线程，所以一个线程能占用的缓冲区就更小了（ 有人以前做过测试，大约一个线程可以占用 128 KB）

    

    